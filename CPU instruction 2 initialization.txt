logic [31:0]instruct_mem[20:0];

initial begin

instruct_mem[0] = 10111000100000000011001111100011;		//LDURSW 0 load 3
instruct_mem[1] = 10111000100000000111001111100111;		//LDURSW 1 load word 7
instruct_mem[2] = 10111000100000000101001111100101;		//LDURSW 2 load word b
instruct_mem[3] = 10111000100000000010001111100010;		//LDURSW		3 load word c
instruct_mem[4] = 10111000100000000100001111100100;		//LDURSW		4 load word d
instruct_mem[5] = 10111000100000001000001111101000;		//LDURSW		5 load word 8
instruct_mem[6] = 11001011000001000000000100001010;		//SUB		6 store A-B into register
instruct_mem[7] = 11001011000000110000000101011111;		//SUB 7 compute A-B - 3
instruct_mem[8] = 01010100000000000000000011011111;		//B.GT 8 B.GT to 14
instruct_mem[9] = 11010011011111110000110001000011;		//LSL 9 R[Rd] = R[Rn] << 3
instruct_mem[10] = 10111000000000000010000001111111;		//STURW 10 store R[Rd] to mem address 3			
instruct_mem[11] = 10111000100000000111001111100111;		//LDURS 11 load word 7
instruct_mem[12] = 10111000000000000100000011111111;		//STURW 12 store 7 to mem address 4
instruct_mem[13] = 00010100000000000000000000000101;		//B 13 branch to end
instruct_mem[14] = 10111000100000000110001111100110;		//LDURSW 14 load word 6
instruct_mem[15] = 10111000100000000110001111100010;		//LDURSW 15 load 6 to reg 2
instruct_mem[16] = 10111000000000000010000011011111;		//STURW 16 store 6 to mem address 2
instruct_mem[17] = 11010011011111110000100010000100;		//LSL 17 R[Rd] = R[Rn] << 2
instruct_mem[18] = 10111000000000000100000010011111;		//STURW 18 store R[Rd] to mem address 

end