module decode(inst, clk, rst, op, reg_en, data_address, sram_RW, ALU_control, Rm, Rn, Rd);
	input  [6:0]  inst_address;
	input  [31:0] inst;
	input	 		  clk, rst;
	output [3:0]  op;
	output [8:0]  data_address;
	output		  reg_en;
	output [1:0]  sram_RW;
	output [4:0]  Rn, Rm, Rd;
	
	always_ff @(posedge clk) begin
		if (rst) begin
			op <= 4'b0;
		end else if (11'h5c0 == inst[31:21]) begin
			// SRAM output enable <= 1'b1;
			op <= 4'b1000; // store
			sram_RW <= 2'b0;
			data_address <= inst[20:12];
			//data_local_data <= A; // value read from the reg file write into SRAM
			Rn <= instR[9:5];
			Rm <= 5'b11111;
			Rd <= 5'b11111;
			
			reg_en <= 1'b0;
			load <= 1'b1;
		end else if (instR[31:21] >= 11'h0a0 && inst[31:21] <= 11'h0bf) begin
			op <= 4'b1001; // B
			reg_en <= 1'b0;
			Rn <= 5'b11111;
			Rm <= 5'b11111;
			Rd <= 5'b11111;
			load <= 1'b0;
			sram_RW <= 2'b2;
		end else if (instR[31:21] == 11'h6b0) begin
			op <= 4'b1010; // BR
			Rn <= instR[4:0];
			Rm <= 5'b11111;
			Rd <= 5'b11111;
			reg_en <= 1'b0;
			sram_RW <= 2'b2;
			load <= 1'b0;
		end else if (inst[31:21] >= 11'h2a0 && inst[31:21] <= 11'h2a7) begin
			op <= 4'b1011; // BGT
			// B, GT need negative flag of the subtraction result
			reg_en <= 1'b0;
			load <= 1'b0;
			sram_RW <= 2'b2;
			/*if (NF != 1'b1 && ZF != 1'b1) 
				pc <= pc + instR[11:5];
			else 
				pc <= pc + 1'b1;*/
		end else if (11'h5c4 == inst[31:21]) begin
			// SRAM output enable <= 1'b0;
			op <= 4'b0111; // load
			data_address <= inst[20:12];
			Rn <= inst[9:5];
			Rm <= inst[20:16];
			Rd <= inst[4:0];
			reg_en <= 1'b1;
			load <= 1'b1;
			sram_RW <= 2'b1;
		end else if (11'h458 == inst[31:21]) begin
			op <= 4'b0001; // ADD 
			Rn <= inst[9:5];
			Rm <= inst[20:16];
			Rd <= inst[4:0];
			reg_en <= 1'b1;
			load <= 1'b0;
			sram_RW <= 2'b2;
		end else if (11'h658 == inst[31:21]) begin
			op <= 4'b0010; // SUB
			Rn <= inst[9:5];
			Rm <= inst[20:16];
			Rd <= inst[4:0];
			reg_en <= 1'b1;
			load <= 1'b0;
			sram_RW <= 2'b2;
		end else if (11'h450 == inst[31:21]) begin
			op <= 4'b0011; // AND
			Rn <= inst[9:5];
			Rm <= inst[20:16];
			Rd <= inst[4:0];
			reg_en <= 1'b1;
			sram_RW <= 2'b2;
			load <= 1'b0;
		end else if (11'h550 == inst[31:21]) begin
			op <= 4'b0100; // ORR
			Rn <= inst[9:5];
			Rm <= inst[20:16];
			Rd <= inst[4:0];
			reg_en <= 1'b1;
			load <= 1'b0;
			sram_RW <= 2'b2;
		end else if (11'h650 == inst[31:21]) begin
			op <= 4'b0101; // XOR
			Rn <= instR[9:5];
			Rm <= instR[20:16];
			Rd <= instR[4:0];
			reg_en <= 1'b1;
			load <= 1'b0;
			sram_RW <= 2'b2;
		end else if (11'h69b == instR[31:21]) begin
			op <= 4'b0110; // LSL
			Rn <= instR[9:5];
			Rm <= instR[20:16];
			Rd <= instR[4:0];
			reg_en <= 1'b1;
			sram_RW <= 2'b2;
			// Din2 <= {26'b0, instR[15:10]};
		end else begin
			op <= 4'b0;
			load <= 1'b0;
			Rn <= 5'b11111;
			Rm <= 5'b11111;
			Rd <= 5'b11111;
			sram_RW <= 2'b2;
			//Wait <= 1'b0;
			/*if (instR == 32'b0) begin
				NOP <= NOP + 1'b1;
				if (NOP > 2'b01) 
					pc <= pc;
			end else 
				pc <= pc + 1'b1;*/
			//pc <= pc + 1'b1;
		end
	end
endmodule
